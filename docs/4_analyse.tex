\section{Analyse}\label{kapitel4}
\subsection{Einleitung}
\subsubsection{Zweck der Anwendung}
Die App soll es ermöglichen, einen Lauf mitzuschneiden, um ihn anschließend an eine Gruppe von Freunden zu veröffentlichen. Diesen ist es dann möglich, mit ihren Freunden zu laufen bzw. gegen diese anzutreten. Läufe sollen regelmäßig (z.B. einmal pro Woche) stattfinden, um ein regelmäßiges zurückkehren zu unserer App und dem Sport zu gewährleisten. Um Läufe vergleichbar zu machen sollen Höhendaten berücksichtigt werden, um Läufern auf bergigen Strecken, die anstrengender zu Laufen sind eine faire Chance zu geben.

Während des Laufes soll ein direkter Vergleich zur Konkurrenz möglich sein. Dies geschieht durch die Einblendung sogenannter Geister, also die Darstellung des Fortschritts der bereits gelaufenen Gegner im Vergleich zum eigenen. Auch während des Laufens werden Nutzer so angetrieben, ihr Bestes zu geben.

Um die Funktionalität zu gewährleisten sind das Schreiben einer Android-App und das Aufzetzen eines Webserver nötig, der als zentraler Datenspeicher agiert und die verschiedenen Nutzer verbindet.
\subsubsection{Projektumfang}
Ziel der App ist es nicht, wie andere Fitness-, bzw. Joggingapps umfangreiche Statistiken anzubieten. Vielmehr konzentrieren wir uns in der Arbeit darauf, Gamification zu nutzen und durch den direkt ersichtlichen Wettbewerb die Nutzer anzuspornen. Statt ausführlicher Statistiken soll ein GPX-Export ermöglicht werden, damit Nutzer ihre Läufe später in beliebiger Software importieren und auswerten können. So ist unsere App keine Konkurrenz zu vielen etablierten Fitnessportalen, sondern lässt sich als Ergänzung nutzen.

Weiterhin ist es keine Anforderung, ein vollständiges Social Network mit Privat- und Gruppenunterhaltungen bereitzustellen. Diese Funktionalität kann in späteren Versionen der App durchaus implementiert werden, ist aber nicht Hauptaspekt der Studienarbeit. Wichtig ist dagegen, Funktionalität anzubieten um Gruppen zu verwalten, also Nutzer hinzuzufügen und zu löschen.

Die Benutzeroberfläche der App soll ansprechend gestaltet werden, dennoch ist sie nicht Hauptaspekt der Arbeit, da dies in Kombination mit der übrigen Funktionalität den Rahmen einer Studienarbeit sprengen würde. Insbesondere der Bildschirm während des Laufens soll hierbei ein Wiedererkennungsmerkmal darstellen. In der Version, die während der Studienarbeit geschrieben wird, soll ersichtlich werden, wie eine spätere, professionell gestaltete Oberfläche aussehen könnte.

Wir können keinen direkten Einfluss auf die Skalierbarkeit und Verfügbarkeit des Webservers nehmen, da dieser auf einer virtuellen Maschine der DHBW läuft. Dennoch sollte der Webserver aus programmatischer Sicht gewissen Performanceanforderungen genügen.
\subsection{Funktionale Anforderungen}
\subsubsection{Webserver}
Der Webserver stellt eine Schnittstelle bereit, die einem Klienten nach der Authentifizierung folgende Funktionalitäten bereitstellt:
\begin{itemize}
\item Nutzer abzufragen, anzulegen und zu löschen,
\item Läufe abzufragen, anzulegen und zu löschen,
\item Gruppen abzufragen, anzulegen und zu löschen,
\item Nutzer zu Gruppen hinzuzufügen oder zu entfernen,
\item Freunde einzuladen und
\item Kacheln für Höhendaten anzufordern und herunterzuladen.
\end{itemize}
\subsubsection{Android App}
Die Android App soll dem Nutzer folgenden Funktionalitäten bereitstellen:
\begin{itemize}
\item Anmeldung beim Webserver
\item Registrierung beim Webserver
\item Abmeldung vom Webserver
\item Laufen ohne währenddessen gegen Freunde anzutreten
\item Laufen um währenddessen die Position der Freunden mitverfolgen zu können
\item Eintreten in Gruppen, Austreten aus Gruppen und Erstellen von Gruppen
\item Einladen appfremder Nutzer in eine Gruppe
\item Einladen anderer Nutzer der App in eine Gruppe
\item Weitergabe des Administratorprivilegs innerhalb der Gruppe durch den Gruppenadministrator
\end{itemize}
\subsection{Nichtfunktionale Anforderungen}
An den Webserver werden folgende Anforderungen gestellt:
\begin{itemize}
\item Die Authentifizierung muss sicher sein, sodass das Passwort des Nutzers und seine persönlichen Daten sicher vor Fremdzugriff und Manipulation durch Unbefugte sind.
\item Der Server muss innerhalb von 5s Sekunden reagieren.
\item Mobile Datenbeschränkungen müssen bedacht werden, sowohl in Bezug auf Geschwindigkeit als auch Datenmengen.
\end{itemize}
%TODO Reliability, Performance, Supportability, Implementation, Interface, Packaging, Legal
\subsubsection{Usability}
Die App muss einfach zu bedienen sein. Wir richten uns allgemein an Sportler und Sportinteressierte. Außer grundlegenden Kenntnissen zur Nutzung von Android-Apps können wir keine Annahmen zu den technischen Fähigkeiten des Nutzers machen.

Teile der App sind für die Nutzung beim Joggen. Auch hierbei muss es dem Nutzer möglich sein relevante Informationen zu erkennen und sicher mit der App zu interagieren.

\subsubsection{Sicherheit}
Um Nutzer zu authentifizieren ist eine Nutzername/Passwort-Vergabe notwendig. Diese müssen ausreichend gesichert sein, um unauthorisierte Zugriffe auf Ressourcen zu verhindern. 

Außerdem muss die Sicherheit des Gerätes zu jedem Zeitpunkt gewährleistet sein, d.h. die Einschleusung über die App von Schadcode darf nicht möglich sein.

\subsection{Use Cases}
%TODO evtl abklären mit anforderungsanalyse
\subsection{Komponenten der Webservers}
%TODO Authentifizierung, Security, Datenspeicherung, file bereitstellung, rest schnittstelle, validierung (evtl das alles woanders?)
\subsection{Komponenten der Android App}
Die folgenden Abschnitte befasst sich mit der Analyse der Komponenten der Ghostrunner App. Notwendig sind für die Aufzeichnung des Laufes beispielsweise eine Möglichkeit der Positions- und Höhenbestimmung. Es muss außerdem eine Möglichkeit der Authentifizierung und Kommunikation mit dem Webserver geben. Die Android Plattform wird auf mögliche Lösungen untersucht, welche hier beschrieben werden.
\subsubsection{Kommunikation mit dem Webserver}
Für die Kommunikation mit dem Webserver muss eine Internetverbindung zur Verfügung stehen. Diese ist bei allen Geräten, auf denen unsere App laufen soll Standard. Programmatisch wird also nur ein HTTP-Client benötigt, der von der Android-Plattform bereitgestellt wird. Er ermöglicht, dass  HTTP-Anfragen wie GET und POST gestellt werden und Informationen in HTTP-Header und Body übergeben werden können. Beim Warten auf Antworten vom Webserver kommt es automatisch zu nicht vorhersehbaren Verzögerungen. Android erlaubt es aus diesem Grund nicht, diese Netzwerkanfragen im Main Thread der App zu starten, weil sonst während der Wartezeiten die komplette Benutzeroberfläche einfriert. Bei den Standard HTTP-Clients von Android kann die Netzwerkanfrage durch die Benutzung der Klasse AsyncTask in einen separaten Thread ausgelagert werden. \footnote{Connecting to a Network, vgl.~\cite{androidnetwork}}

Vereinfacht werden kann dieser Schritt durch die Benutzung des Android Asynchronous HTTP Client. Die quelloffene Bibliothek bietet einfache funktionen für die HTTP-Anfragen GET, POST, PUT und DELETE, die für die Kommunikation mit RESTful-APIs notwendig sind und empfängt Antworten vom Server automatisch asynchron, wodurch der UI-Thread nicht blockiert wird. \footnote{Android Asynchronous Http Client, vgl.~\cite{loopj}}
\subsubsection{Anmeldung und Authentifizierung}
Ein weiterer wichtiger Aspekt ist die Authentifizierung beim Webserver. Nach einer Anmeldung mit Nutzername und Passwort wird vom Server ein Sicherheitstoken erstellt, das bis zu seinem ebenfalls vom Server definierten Ablaufdatum von Client benutzt werden kann, um sich anzumelden. So kann bei einem eventuellen Angriff auf die Netzwerkkommunikation nur noch ein zeitlich, nicht mehr die vollständigen
Es macht Sinn, diese Authentifizierung an einer einzigen Stelle im Client zu behandeln.
%TODO
\subsubsection{Positionsbestimmung}
Für eine genaue Laufanalyse muss zu jedem Zeitpunkt die Position des Läufers bekannt sein, denn daraus lassen sich Geschwindigkeit und gelaufene Strecke berechnen. Die Positionsbestimmung erfolgt über das eingebaute GPS-Modul des Smartphones, dessen Genauigkeit in Städten durch WLAN-basierte Ortung und GSM-Ortung durch das Mobilfunknetz verbessert werden kann. Die Module zur Ortung können über das Package android.location der Android API angesprochen werden. Eine Positionsbestimmung ist also mit Boardmitteln eines Android Smartphones ohne Umwege möglich. Eine neuere und verbesserte Möglichkeit bietet die Google Location Services API. Sie ist Teil der Google Play Services, also auf allen Android Geräten verfügbar, die diesen und andere Google Dienste installiert haben, was einem Großteil der Geräte entspricht. Die verschiedenen Ortungsmöglichkeiten werden hier optimiert und zusammengeführt. Programmierer können auf einfache Weise Positionsupdates anfordern und diese über verschiedene Parameter bezüglich Genauigkeit, Updatehäufigkeit und Akkuverbrauch seinen Bedürfnissen anpassen. \footnote{Location Strategies, vgl.~\cite{androidlocation}}
\subsubsection{Höhenbestimmung}
Zusätzlich zu Positions- und Zeitmessung wird für unsere Anwendung noch eine weitere Variable - die Steigung - benötigt. Wenn Läufer verschiedene Strecken laufen, muss diese berücksichtigt werden, um einen fairen Vergleich zu schaffen. Dazu soll später Läufern, die eine größere Steigung überwinden mussten als andere ein Zeitbonus zugesprochen werden.

Für die Bestimmung der Höhe gibt es verschiedene Möglichkeiten, die im Folgenden kurz erläutert werden.
\paragraph{Höhenbestimmung per GPS}
Grundsätzlich ist per GPS eine dreidimensionale Positionsbestimmung möglich, also neben der horizontalen Positionierung auch eine vertikale Höhenmessung. Diese kann jedoch aufgrund der für horizontale Positionsbestimmung optimierten Positionierung der GPS-Satelliten starken Schwankungen unterliegen. Insbesondere in Städten kommt hierzu das Problem der Reflektion des GPS Signals an hohen Gebäuden, durch die die Positionsgenauigkeit weiter beeinträchtigt wird. Die Beeinträchtigung ist horizontal weniger signifikant als vertikal, und wird durch die Nutzung der im vorherigen Abschnitt genannten zusätzlichen Positionierungsmethoden noch weiter optimiert. Vertikal ist eine solche Optimierung nicht möglich. Noch größer ist die Fehlersignifikanz bei dem Versuch, die Höhe über Normalnull zu berechnen, die von dem vom GPS-System genutzten rein mathematischen Ellipsoid WGS-84 abweicht. Durch die Umrechnung vergrößern sich entsprechende Fehler. \footnote{Discussion of vertical GPS Accuracy, vgl.~\cite{gladstone}} Letzeres ist allerdings für unsere Arbeit aber nicht relevant, da wir keine genaue Höhe, sondern nur die relativen Unterschiede für die Steigungsberechnung benötigen. Trotzdem können die möglichen starken Schwankungen der gemessenen Höhe für unsere Anwendung zum Problem werden.
\paragraph{Höhenbestimmung per Web-API}
%TODO
\paragraph{Höhenbestimmung per SRTM-Rohdaten}
%TODO
\paragraph{Kombination verschiedener Methoden}
%TODO anpassen
Insbesondere durch Kombination von GPS und und Nutzung der SRTM-Daten sollten sich sehr genaue Ergebnisse erzielen lassen. Die Implementierung des Höhenbestimmungsmoduls sollte also flexibel genug sein, um das zuzulassen. Erreicht wird diese Flexibilität durch die Implementierung eines Interfaces ElevationService, das die Methode getElevation(double latitude, double longitude) besitzt. Durch Nutzung dieses Interfaces können verschiedene Services einfach ausgetauscht oder mit wenig zusätzlichem Programmieraufwand kombiniert werden. Hier muss nur noch ein Algorithmus entwickelt werden, der bestimmt, auf welche Weise verschiedene Höhendaten kombiniert werden. Für die Studienarbeit haben wir uns aber für die explizite Implementierung der SRTM-Methode entschieden, Veränderungen in späteren Versionen sind durch das Interface jederzeit ohne großen Aufwand möglich.
\subsubsection{Aufzeichnen des Laufes}
%TODO
\subsubsection{Frontend der Android App}
%TODO
\subsubsection{Darstellung des Laufes}
%TODO

\subsection{Analyse von Entitäten}
%TODO ER Diagramm aufgrund von use cases: gruppen, läufe und so quatsch