\section{Analyse}\label{kapitel4}
\subsection{Einleitung}
\subsubsection{Zweck der Anwendung}
Die App soll es ermöglichen, einen Lauf mitzuschneiden, um ihn anschließend an eine Gruppe von Freunden zu veröffentlichen. Diesen ist es dann möglich, mit ihren Freunden zu laufen bzw. gegen diese anzutreten. Läufe sollen regelmäßig (z.B. einmal pro Woche) stattfinden, um ein regelmäßiges zurückkehren zu unserer App und dem Sport zu gewährleisten. Um Läufe vergleichbar zu machen sollen Höhendaten berücksichtigt werden, um Läufern auf bergigen Strecken, die anstrengender zu Laufen sind eine faire Chance zu geben.

Während des Laufes soll ein direkter Vergleich zur Konkurrenz möglich sein. Dies geschieht durch die Einblendung sogenannter Geister, also die Darstellung des Fortschritts der bereits gelaufenen Gegner im Vergleich zum eigenen. Auch während des Laufens werden Nutzer so angetrieben, ihr Bestes zu geben.

Um die Funktionalität zu gewährleisten sind das Schreiben einer Android-App und das Aufzetzen eines Webserver nötig, der als zentraler Datenspeicher agiert und die verschiedenen Nutzer verbindet.
\subsubsection{Projektumfang}
Ziel der App ist es nicht, wie andere Fitness-, bzw. Joggingapps umfangreiche Statistiken anzubieten. Vielmehr konzentrieren wir uns in der Arbeit darauf, Gamification zu nutzen und durch den direkt ersichtlichen Wettbewerb die Nutzer anzuspornen. Statt ausführlicher Statistiken soll ein GPX-Export ermöglicht werden, damit Nutzer ihre Läufe später in beliebiger Software importieren und auswerten können. So ist unsere App keine Konkurrenz zu vielen etablierten Fitnessportalen, sondern lässt sich als Ergänzung nutzen.

Weiterhin ist es keine Anforderung, ein vollständiges Social Network mit Privat- und Gruppenunterhaltungen bereitzustellen. Diese Funktionalität kann in späteren Versionen der App durchaus implementiert werden, ist aber nicht Hauptaspekt der Studienarbeit. Wichtig ist dagegen, Funktionalität anzubieten um Gruppen zu verwalten, also Nutzer hinzuzufügen und zu löschen.

Die Benutzeroberfläche der App soll ansprechend gestaltet werden, dennoch ist sie nicht Hauptaspekt der Arbeit, da dies in Kombination mit der übrigen Funktionalität den Rahmen einer Studienarbeit sprengen würde. Insbesondere der Bildschirm während des Laufens soll hierbei ein Wiedererkennungsmerkmal darstellen. In der Version, die während der Studienarbeit geschrieben wird, soll ersichtlich werden, wie eine spätere, professionell gestaltete Oberfläche aussehen könnte.

Wir können keinen direkten Einfluss auf die Skalierbarkeit und Verfügbarkeit des Webservers nehmen, da dieser auf einer virtuellen Maschine der DHBW läuft. Dennoch sollte der Webserver aus programmatischer Sicht gewissen Performanceanforderungen genügen.
\subsection{Funktionale Anforderungen}
\subsubsection{Webserver}
Der Webserver stellt dem Klienten eine Schnittstelle bereit, um Nutzer, Gruppen und Läufe zu verwalten. Er muss dabei folgende Funktionale Anforderungen erfüllen:
\begin{itemize}
\item Authentifizierung durch Nutzername und Passwort
\item Erstellen und Herausgeben eines Authentifizierungstokens bei Erfolg
\item Authentifizierung durch das Authentifizierungstoken, Zuordnung zum jeweiligen Nutzer
\item Erstellen und Löschen von Nutzern
\item Ausgabe und Modifikation von Nutzerdaten
\item Erstellen und Löschen von Gruppen
\item Ausgabe und Modifikation von Gruppendaten
\item Hinzufügen und Entfernen von Nutzern zu Gruppen
\item Unterscheidung von Gruppenadministratoren und Nutzern
\item Einladen von Nutzern in Gruppen
\item Annehmen und Ablehnen von Einladungen
\item Verwaltung regelmäßiger Stichtage zur Laufauswertung
\item Erstellen und Ausgeben von Läufen, abhängig von Nutzer und Gruppe
\item Ausgabe von Kacheln mit Höhendaten
\end{itemize}
\subsubsection{Android App}
Die Android App muss folgende Funktionalität erfüllen:
\begin{itemize}
\item Anmeldung beim Webserver mit Nutzername und Passwort
\item Speicherung von Anmeldedaten
\item Speicherung des Authentifizierungstokens
\item Authentifizierung beim Webserver mit Authentifizierungstoken
\item Registrierung beim Webserver
\item Abmeldung inklusive Entfernung von Token und Anmeldedaten
\item Anzeigen einer Übersichte aller Gruppen
\item Erstellen von neuen Gruppen
\item Anzeigen einer Übersicht aller Nutzer und aktuellen Läufe einer Gruppe, inklusiver aktueller Platzierung
\item Einladen von bereits vorhandenen Nutzern in eine Gruppe
\item Einladen von appfremden Nutzern in eine Gruppe
\item Löschen von Nutzern aus einer Gruppe
\item Aufzeichnung von Läufen und Übergabe an den Server
\item Exportieren von Läufen im GPX Format
\item Darstellung des Lauffortschritts und Anzeige von Geistern
\item Darstellung einer Statistikseite am Ende von Läufen
\end{itemize}
\subsection{Nichtfunktionale Anforderungen}
\subsubsection{Performanz}
Sowohl die App als auch der Server müssen so konzipiert werden, dass schnelle Reaktionszeiten möglich sind. Ladezeiten sollten für den Nutzer minimiert werden. Insbesondere muss eine Einfrieren der Nutzeroberfläche vermieden werden, längere Berechnungen oder Downloads sollen im Hintergrund ablaufen.

Versendete Datenmengen sollten minimiert werden, da die Verbindungsgeschwindigkeit und -verfügbarkeit gerade während den Läufen nicht garantiert werden kann.
\subsubsection{Usability}
Die App muss einfach zu bedienen sein. Wir richten uns allgemein an Sportler und Sportinteressierte. Außer grundlegenden Kenntnissen zur Nutzung von Android-Apps können wir keine Annahmen zu den technischen Fähigkeiten des Nutzers machen.

Teile der App sind für die Nutzung beim Joggen. Auch hierbei muss es dem Nutzer möglich sein relevante Informationen zu erkennen und sicher mit der App zu interagieren.
\subsubsection{Sicherheit}
Um Nutzer am Server zu authentifizieren ist eine Nutzername/Passwort-Vergabe notwendig. Sie dient zum einen zum Wiedererkennen einzelner Nutzer, als auch um unbefugte Zugriffe auf den Server zu verhindern. Um das Passwort des Nutzers und seine persönlichen Daten zu sichern, müssen diese verschlüsselt gespeichert und versendet werden.

Außerdem muss die Sicherheit des Gerätes zu jedem Zeitpunkt gewährleistet sein, d.h. die Einschleusung über die App von Schadcode darf nicht möglich sein.
\subsection{Use Cases}
%TODO Roland
\subsection{Komponenten der Webservers}
%TODO Authentifizierung, Security, Datenspeicherung, file bereitstellung, rest schnittstelle, validierung (evtl das alles woanders?), verschlüsselung pw, Einladungen
Der Webserver dient zur Bereitstellung verschiedener Informationen für die App anhand einer REST-Schnitstelle. 

Im folgenden geht dieses Dokument auf die unterschiedlichen Komponenten des Webservers ein.
\subsubsection{REST API}
\paragraph{Sicherheit}
Um den Zugriff auf die eigenen Daten einzuschränken ist eine Nutzerauthentifizierung nötig. Aufgrund der Zustandslosigkeit, die eine REST-API mit sich bringt, ist die Authentifizierung innerhalb einer Sitzung ausgeschlossen. Nach Definition muss jede Nachricht genügend Informationen enthalten damit der Server die Anfrage verstehen kann, welche durch sitzungsspezifische Informationen stattdessen serverseitig gespeichert werden müssten.

Eine gute Alternative ist hier die Authentifizierung anhand eines Tokens, für die wir uns entschieden haben. Der Client sendet hierbei eine Anfrage an die Authentifierungs-URL an den Server in der Nutzername und Passwort enthalten sind. Sind diese korrekt erhält er ein Token, welches er von da an mit jeder Anfrage an den Server mitschickt.

Dem Token ist eine Lebenszeit zugeordnert. Ist diese überschritten und versucht sich der Nutzer mit dem Token anzumelden erhalt er den HTTP Status ``Unauthorized'' mit Statuscode 401. Dann muss sich erneut authentifiziert werden um ein aktuelles Token zu erhalten.

Für den Rahmen des Projekts haben wir uns auf eine Lebenszeit von drei Tagen festgelegt. Je geringer die Lebenszeit, desto mehr erneute Authentifizierungen durch den Nutzer müssen durchgeführt werden. Das sorgt zwar für höheren Datenverkehr, verkürzt jedoch auch die Zeit, die sich Unbefugte Zugriff verschaffen können, falls sie das Token abgreifen konnten. 
\paragraph{Validierung}
Nutzeranfragen müssen validiert werden um deren Korrektheit zu gewährleisten.

So sind Beschränkungen notwendig, z.B. bei der Passwort- oder Nutzernamenlänge. Auch werden u.A. E-Mail-Adressen validiert, um sie auf die korrekte Form zu prüfen.

Schlägt die Prüfung fehl gibt der Server die Nachricht ``Bad Request'' mit Statuscode 400 zurück, zusammen mit einer aussagekräftigen Nachricht. Das ermöglicht der App diese den Nutzern weiterzugeben um die Korrektur der Eingaben zu vereinfachen.

Die Validierung erfolgt mit dem Java Bean Validation Framework. Dieses ermöglicht annotationsbasierte Validierung von Anfragen.
\subsubsection{Datenspeicherung}
Die lokale Speicherung von Daten auf dem Server ist aus unterschiedlichen Gründen notwendig.

Für eine Authentifizierung ist das persistente Sichern von Nutzerinformationen auf dem Backend-Server nötig. Die sozialen Funktionen erfordern außerdem das zentralisierte Speichern der Läufe, Gruppen und Einladungen.

Um eine organisierte Struktur mit klar definierten Relationen und einen einfach späteren Zugriff zu ermöglichen haben wir uns für die Datenbank MariaDB entschieden, einer performanten quelloffenen SQL-Datenbank.
\paragraph{Bereitstellung der SRTM-Rohdaten}
Um dem Android-Smartphone positionsbezogene Höhendaten bereitzustellen befindet sich ein große Menge an verpackten Höhendaten auf dem Server.

Für jedes Quadrat aus einem Höhen- und einem Breitengrad (welches Informationen enthält) befindet sich auf dem Server eine Zip-komprimierte Datei. Damit entsteht letztendlich eine Dateizahl von 17.387.

Um eine derart große Menge struktur zu bewältigen sind die Dateien in einer Ordnerstruktur der Form <Breitengrad>/<Höhengrad>.zip angelegt.
\subsection{Komponenten der Android App}
Die folgenden Abschnitte befasst sich mit der Analyse der Komponenten der Ghostrunner App. Notwendig sind für die Aufzeichnung des Laufes beispielsweise eine Möglichkeit der Positions- und Höhenbestimmung. Es muss außerdem eine Möglichkeit der Authentifizierung und Kommunikation mit dem Webserver geben. Die Android Plattform wird auf mögliche Lösungen untersucht, welche hier beschrieben werden.
\subsubsection{Kommunikation mit dem Webserver}
Für die Kommunikation mit dem Webserver muss eine Internetverbindung zur Verfügung stehen. Diese ist bei allen Geräten, auf denen unsere App laufen soll Standard. Programmatisch wird also nur ein HTTP-Client benötigt, der von der Android-Plattform bereitgestellt wird. Er ermöglicht, dass  HTTP-Anfragen wie GET und POST gestellt werden und Informationen in HTTP-Header und Body übergeben werden können. Beim Warten auf Antworten vom Webserver kommt es automatisch zu nicht vorhersehbaren Verzögerungen. Android erlaubt es aus diesem Grund nicht, diese Netzwerkanfragen im Main Thread der App zu starten, weil sonst während der Wartezeiten die komplette Benutzeroberfläche einfriert. Bei den Standard HTTP-Clients von Android kann die Netzwerkanfrage durch die Benutzung der Klasse AsyncTask in einen separaten Thread ausgelagert werden. \footnote{Connecting to a Network, vgl.~\cite{androidnetwork}}

Vereinfacht werden kann dieser Schritt durch die Benutzung des Android Asynchronous HTTP Client. Die quelloffene Bibliothek bietet einfache funktionen für die HTTP-Anfragen GET, POST, PUT und DELETE, die für die Kommunikation mit RESTful-APIs notwendig sind und empfängt Antworten vom Server automatisch asynchron, wodurch der UI-Thread nicht blockiert wird. \footnote{Android Asynchronous Http Client, vgl.~\cite{loopj}}
\subsubsection{Anmeldung und Authentifizierung}
Ein weiterer wichtiger Aspekt ist die Authentifizierung beim Webserver. Nach einer Anmeldung mit Nutzername und Passwort wird vom Server ein Sicherheitstoken erstellt, das bis zu seinem ebenfalls vom Server definierten Ablaufdatum von Client benutzt werden kann, um sich zu authentifizieren.

Es macht Sinn, diese Authentifizierung an einer einzelnen, dafür dedizierten Stelle im Client zu behandeln. Eine zentrale Speicherung von Anmeldedaten und Sicherheitstoken stellt sicher, dass eine Authentifizierung beim Webserver für alle App-Komponenten möglich ist.

Sobald ein Token abgelaufen ist, ist mit ihm keine weitere Authentifizierung möglich, was durch den HTTP-Statuscode 401 vom Server kommuniziert wird. In diesem Fall muss der die Authentifizierungsstelle der Android App durch erneutes senden der Anmeldedaten einen neuen Token anfordern, woraufhin die ursprüngliche Anfrage wiederholt werden kann.

Bei einem Logout müssen sowohl das aktuelle Authentifizierungstoken, als auch die gespeicherten Nutzerdaten gelöscht werden. Eine Authentifizierung beim Server ist dann erst nach erneuter Anmeldung wieder möglich.
\subsubsection{Positionsbestimmung}
Für eine genaue Laufanalyse muss zu jedem Zeitpunkt die Position des Läufers bekannt sein, denn daraus lassen sich Geschwindigkeit und gelaufene Strecke berechnen. Die Positionsbestimmung erfolgt über das eingebaute GPS-Modul des Smartphones, dessen Genauigkeit in Städten durch WLAN-basierte Ortung und GSM-Ortung durch das Mobilfunknetz verbessert werden kann. Die Module zur Ortung können über das Package android.location der Android API angesprochen werden. Eine Positionsbestimmung ist also mit Boardmitteln eines Android Smartphones ohne Umwege möglich. Eine neuere und verbesserte Möglichkeit bietet die Google Location Services API. Sie ist Teil der Google Play Services, also auf allen Android Geräten verfügbar, die diesen und andere Google Dienste installiert haben, was einem Großteil der Geräte entspricht. Die verschiedenen Ortungsmöglichkeiten werden hier optimiert und zusammengeführt. Programmierer können auf einfache Weise Positionsupdates anfordern und diese über verschiedene Parameter bezüglich Genauigkeit, Updatehäufigkeit und Akkuverbrauch seinen Bedürfnissen anpassen. \footnote{Location Strategies, vgl.~\cite{androidlocation}}
\subsubsection{Höhenbestimmung}
Zusätzlich zu Positions- und Zeitmessung wird für unsere Anwendung noch eine weitere Variable - die Steigung - benötigt. Wenn Läufer verschiedene Strecken laufen, muss diese berücksichtigt werden, um einen fairen Vergleich zu schaffen. Dazu soll später Läufern, die eine größere Steigung überwinden mussten als andere ein Zeitbonus zugesprochen werden.

Für die Bestimmung der Höhe gibt es verschiedene Möglichkeiten, die im Folgenden kurz erläutert werden.
\paragraph{Höhenbestimmung per GPS}
Grundsätzlich ist per GPS eine dreidimensionale Positionsbestimmung möglich, also neben der horizontalen Positionierung auch eine vertikale Höhenmessung. Diese kann jedoch aufgrund der für horizontale Positionsbestimmung optimierten Positionierung der GPS-Satelliten starken Schwankungen unterliegen. Insbesondere in Städten kommt hierzu das Problem der Reflektion des GPS Signals an hohen Gebäuden, durch die die Positionsgenauigkeit weiter beeinträchtigt wird. Die Beeinträchtigung ist horizontal weniger signifikant als vertikal, und wird durch die Nutzung der im vorherigen Abschnitt genannten zusätzlichen Positionierungsmethoden noch weiter optimiert. Vertikal ist eine solche Optimierung nicht möglich. Noch größer ist die Fehlersignifikanz bei dem Versuch, die Höhe über Normalnull zu berechnen, die von dem vom GPS-System genutzten rein mathematischen Ellipsoid WGS-84 abweicht. Durch die Umrechnung vergrößern sich entsprechende Fehler. \footnote{Discussion of vertical GPS Accuracy, vgl.~\cite{gladstone}} Letzteres ist für unsere Arbeit nicht relevant, da wir keine genaue Höhe, sondern nur die relativen Unterschiede für die Steigungsberechnung benötigen. Trotzdem können die möglichen starken Schwankungen der gemessenen Höhe für unsere Anwendung zum Problem werden.
\paragraph{Höhenbestimmung per Web-API}
Für die Höhenbestimmung gibt es die Möglichkeit, verschiedene Web-APIs zu benutzen. Diese geben nach einer HTTP-Anfrage mit übergebenem Längen- und Breitengrad einen Wert für die Höhe an der aktuellen Position zurück. Aufgrund des bereits existierenden HTTP-Klienten wären solche Dienste einfach zu implementieren.

Eine mögliche Variante ist die Google Elevation API. Sie unterliegt allerdings neben einer maximalen Anfragemenge pro Tag der Restriktion, dass sie nur in Verbindung mit einer Darstellung auf Google Maps verwendet werden darf.\footnote{The Google Elevation API, vgl.~\cite{googleelevation}}  Da unsere App ohne Karte funktionieren soll und keinerlei Navigation anbieten, sondern lediglich Läufe aufzeichnen soll, fällt diese Möglichkeit deshalb aus.

Eine Alternative ist die Benutzung der MapQuest Elevation API. Die Benutzung dieses Service ist frei, käme also für unsere Anwendung in Frage. Dennoch kann sich durch die Abhängigkeit von einem fremden Service ein Skalierungsproblem ergeben, wenn sich die Nutzerzahl unserer App vergrößert. \footnote{MapQuest Open Elevation API Web Service, vgl.~\cite{mapquest}}

Eine weitere Möglichkeit wäre, den Webservice mithilfe der im nächsten Abschnitt beschriebenen SRTM-Rohdaten auf unserem Webserver selbst zu implementieren.

Bei Benutzung einer Web-API entsteht für unsere Anwendung generell ein signifikanter Nachteil. Eine Internetverbindung müsste zu jeder Zeit gewährleistet sein, was insbesondere bei Läufen in abgelegenen Gebieten nicht immer der Fall ist. Dieses Problem steht der gewünschten Echtzeit-Aufzeichnung des Laufes im Weg.
\paragraph{Höhenbestimmung per SRTM-Rohdaten}
%TODO Roland
\paragraph{Kombination verschiedener Methoden}
Insbesondere durch Kombination von GPS und und Nutzung der SRTM-Daten sollten sich sehr genaue Ergebnisse erzielen lassen. Die Implementierung des Höhenbestimmungsmoduls sollte also flexibel genug sein, um das zuzulassen. Erreicht wird diese Flexibilität durch die Implementierung eines Interfaces ElevationService, das die Methode getElevation(double latitude, double longitude) besitzt. Durch Nutzung dieses Interfaces können verschiedene Services einfach ausgetauscht oder mit wenig zusätzlichem Programmieraufwand kombiniert werden. Hier muss nur noch ein Algorithmus entwickelt werden, der bestimmt, auf welche Weise verschiedene Höhendaten kombiniert werden. Für die Studienarbeit haben wir uns explizit für die Implementierung der SRTM-Methode entschieden, Veränderungen in späteren Versionen sind durch das Interface jederzeit ohne großen Aufwand möglich.
\subsubsection{Aufzeichnen des Laufes}
Für die Aufzeichnung des Laufes sind nun alle wichtigen Voraussetzungen geschaffen. Nach regelmäßigen Positionsupdates werden die zugehörigen Höhendaten abgefragt. Daraufhin kann die zurückgelegte Strecke schrittweise im Vergleich zur seit Laufbeginn vergangenen Zeit berechnet werden. Ist die vorgegebene Laufstrecke erreicht, gilt dieser als beendet.

Zusätzlich zur Berechnung der zurückgelegten Strecke werden die aufgezeichneten Wegpunkte bei jedem Positionsupdate in eine GPX-Datei geschrieben. Jeder Wegpunkt enthält einen Zeitstempel, Längen- und Breitengrad, sowie die aktuelle Höhe.

Eine Variante, um einen Ausgleich zwischen verschieden steilen Strecken zu schaffen ist es, statt der Zielzeit eine unabhängig davon errechneten Punktzahl für den Vergleich der Läufer heranzuziehen. Diese würde in steilen Streckenabschnitten schneller erhöht werden als in flachen.

Um die App für den Benutzer aber möglichst simpel und durchsichtig zu halten, haben wir uns für eine andere Methode entschieden. Hierbei wird für jeden Abschnitt zwischen zwei Positionsupdates ein Multiplikator errechnet. Auf steilen Strecken wird der zurückgelegte Weg mit einer Zahl größer als eins multipliziert, der Läufer kommt also entsprechend früher ins Ziel. Läuft er bergab, erst etwas später. Auf einer Strecke von beispielsweise einem Kilometer mit konstanter Steigung, für die ein Multiplikator von 1,1 errechnet wurde, würde der Nutzer sein Ziel also schon nach 909 Metern erreichen.

Der Vergleich mit anderen Läufern ist in dieser Variante sehr einfach möglich, denn der Abstand zu den Geistern kann zu jedem Zeitpunkt in Metern angegeben werden. Bei einer willkürlich gewählten Punktzahl wäre dieser für den Nutzer schwieriger nachzuvollziehen.

Zunächst ist noch unklar, wie groß der Multiplikator sein muss, um einen fairen Vergleich zu schaffen. Eine genaue Berechnung kann sicher erst nach ausführlichen Tests gefunden werden. Auch dann sind perfekte Multiplikatoren unwahrscheinlich, denn jeder Läufer reagiert unterschiedlich auf verschiedene Steigungen.

Sicher ist, dass auch ein Teil der vergangenen Strecke für die Berechnung herangezogen werden muss, denn eine moderate Steigung über längere Zeit zu überwinden kann schwieriger sein, als über einen sehr kurzen Zeitraum mit extremer Steigung zu laufen.
\subsubsection{Darstellung des Laufes}
Für die Darstellung des Laufes muss ein eigenes UI Element gestaltet werden. Informationen wie der aktuelle Fortschritt in Metern und Prozent, die verbleibende Strecke und die vergangene Zeit seit Beginn des Laufes müssen hier ansprechend und wiedererkennbar dargestellt werden.

Zusätzlich muss eine Vergleich zu vorher gelaufenen Mitstreitern möglich sein, eine grafische Fortschrittsanzeige sollte also den aktuellen Läufer im direkten Vergleich mit möglichen Geistern anzeigen. Eine Positionsanzeige ist hier zusätzlich sinnvoll.
\subsubsection{Frontend der Android App}
Andere Elemente der Benutzeroberfläche sollten sich mit Standard UI Elementen des Android Systems, wie Buttons, Textfeldern und Auswahllisten darstellen lassen. Wichtig ist hier ausßerdem ein globales Hauptmenü, über dass sich in Gruppenansichten wechseln oder Läufe starten lassen.