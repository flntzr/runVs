\section{Analyse}\label{kapitel4}
\subsection{Einleitung}
%TODO Purpose of the system, Scope of the system, Objectives and success criteria of the project, Definition acronyms and abbreviations, References, Overview 
Die App soll es ermöglichen, einen Lauf mitzuschneiden, um ihn anschließend an eine Gruppe an Freunden zu veröffentlichen. Diesen ist es dann möglich, mit ihren Freunden zu laufen bzw. gegen diese anzutreten. 

Um diese Funktionalität zu ermöglichen sind das Schreiben einer Android-App und das Aufzetzen eines Webserver nötig.
\subsection{Funktionale Anforderungen}
\subsubsection{Webserver}
Der Webserver stellt eine Schnittstelle bereit, die einem Klienten nach der Authentifizierung folgende Funktionalitäten bereitstellt:
\begin{itemize}
\item Nutzer abzufragen, anzulegen und zu löschen,
\item Läufe abzufragen, anzulegen und zu löschen,
\item Gruppen abzufragen, anzulegen und zu löschen,
\item Nutzer zu Gruppen hinzuzufügen oder zu entfernen,
\item Freunde einzuladen und
\item Kacheln für Höhendaten anzufordern und herunterzuladen.
\end{itemize}
\subsubsection{Android App}
Die Android App soll dem Nutzer folgenden Funktionalitäten bereitstellen:
\begin{itemize}
\item Anmeldung beim Webserver
\item Registrierung beim Webserver
\item Abmeldung vom Webserver
\item Laufen ohne währenddessen gegen Freunde anzutreten
\item Laufen um währenddessen die Position der Freunden mitverfolgen zu können
\item Eintreten in Gruppen, Austreten aus Gruppen und Erstellen von Gruppen
\item Einladen appfremder Nutzer in eine Gruppe
\item Einladen anderer Nutzer der App in eine Gruppe
\item Weitergabe des Administratorprivilegs innerhalb der Gruppe durch den Gruppenadministrator
\end{itemize}
\subsection{Nichtfunktionale Anforderungen}
An den Webserver werden folgende Anforderungen gestellt:
\begin{itemize}
\item Die Authentifizierung muss sicher sein, sodass das Passwort des Nutzers und seine persönlichen Daten sicher vor Fremdzugriff und Manipulation durch Unbefugte sind.
\item Der Server muss innerhalb von 5s Sekunden reagieren.
\item Mobile Datenbeschränkungen müssen bedacht werden, sowohl in Bezug auf Geschwindigkeit als auch Datenmengen.
\end{itemize}
%TODO Reliability, Performance, Supportability, Implementation, Interface, Packaging, Legal
\subsubsection{Usability}
Die App muss einfach zu bedienen sein. Wir richten uns allgemein an Sportler und Sportinteressierte. Außer grundlegenden Kenntnissen zur Nutzung von Android-Apps können wir keine Annahmen zu den technischen Fähigkeiten des Nutzers machen.

Teile der App sind für die Nutzung beim Joggen. Auch hierbei muss es dem Nutzer möglich sein relevante Informationen zu erkennen und sicher mit der App zu interagieren.

\subsubsection{Sicherheit}
Um Nutzer zu authentifizieren ist eine Nutzername/Passwort-Vergabe notwendig. Diese müssen ausreichend gesichert sein, um unauthorisierte Zugriffe auf Ressourcen zu verhindern. 

Außerdem muss die Sicherheit des Gerätes zu jedem Zeitpunkt gewährleistet sein, d.h. die Einschleusung über die App von Schadcode darf nicht möglich sein.

\subsection{Use Cases}
%TODO evtl abklären mit anforderungsanalyse
\subsection{Komponenten der Webservers}
%TODO Authentifizierung, Security, Datenspeicherung, file bereitstellung, rest schnittstelle, validierung (evtl das alles woanders?), verschlüsselung pw, Einladungen
Der Webserver dient zur Bereitstellung verschiedener Informationen für die App anhand einer REST-Schnitstelle. 

Im folgenden geht dieses Dokument auf die unterschiedlichen Komponenten des Webservers ein.
\subsubsection{REST API}
\paragraph{Sicherheit}
Um den Zugriff auf die eigenen Daten einzuschränken ist eine Nutzerauthentifizierung nötig. Aufgrund der Zustandslosigkeit, die eine REST-API mit sich bringt, ist die Authentifizierung innerhalb einer Sitzung ausgeschlossen. Nach Definition muss jede Nachricht genügend Informationen enthalten damit der Server die Anfrage verstehen kann, welche durch sitzungsspezifische Informationen stattdessen serverseitig gespeichert werden müssten.

Eine gute Alternative ist hier die Authentifizierung anhand eines Tokens, für die wir uns entschieden haben. Der Client sendet hierbei eine Anfrage an die Authentifierungs-URL an den Server in der Nutzername und Passwort enthalten sind. Sind diese korrekt erhält er ein Token, welches er von da an mit jeder Anfrage an den Server mitschickt.

Dem Token ist eine Lebenszeit zugeordnert. Ist diese überschritten und versucht sich der Nutzer mit dem Token anzumelden erhalt er den HTTP Status ``Unauthorized'' mit Statuscode 401. Dann muss sich erneut authentifiziert werden um ein aktuelles Token zu erhalten.

Für den Rahmen des Projekts haben wir uns auf eine Lebenszeit von drei Tagen festgelegt. Je geringer die Lebenszeit, desto mehr erneute Authentifizierungen durch den Nutzer müssen durchgeführt werden. Das sorgt zwar für höheren Datenverkehr, verkürzt jedoch auch die Zeit, die sich Unbefugte Zugriff verschaffen können, falls sie das Token abgreifen konnten. 
\paragraph{Validierung}
Nutzeranfragen müssen validiert werden um deren Korrektheit zu gewährleisten.

So sind Beschränkungen notwendig, z.B. bei der Passwort- oder Nutzernamenlänge. Auch werden u.A. E-Mail-Adressen validiert, um sie auf die korrekte Form zu prüfen.

Schlägt die Prüfung fehl gibt der Server die Nachricht ``Bad Request'' mit Statuscode 400 zurück, zusammen mit einer aussagekräftigen Nachricht. Das ermöglicht der App diese den Nutzern weiterzugeben um die Korrektur der Eingaben zu vereinfachen.

Die Validierung erfolgt mit dem Java Bean Validation Framework. Dieses ermöglicht annotationsbasierte Validierung von Anfragen.
\subsubsection{Datenspeicherung}
Die lokale Speicherung von Daten auf dem Server ist aus unterschiedlichen Gründen notwendig.

Für eine Authentifizierung ist das persistente Sichern von Nutzerinformationen auf dem Backend-Server nötig. Die sozialen Funktionen erfordern außerdem das zentralisierte Speichern der Läufe, Gruppen und Einladungen.

Um eine organisierte Struktur mit klar definierten Relationen und einen einfach späteren Zugriff zu ermöglichen haben wir uns für die Datenbank MariaDB entschieden, einer performanten quelloffenen SQL-Datenbank.
\paragraph{Bereitstellung der SRTM-Rohdaten}
Um dem Android-Smartphone positionsbezogene Höhendaten bereitzustellen befindet sich ein große Menge an verpackten Höhendaten auf dem Server.

Für jedes Quadrat aus einem Höhen- und einem Breitengrad (welches Informationen enthält) befindet sich auf dem Server eine Zip-komprimierte Datei. Damit entsteht letztendlich eine Dateizahl von 17.387.

Um eine derart große Menge struktur zu bewältigen sind die Dateien in der Form <Breitengrad>/<Höhengrad>.zip angelegt.
\subsection{Komponenten der Android App}
Die folgenden Abschnitte befasst sich mit der Analyse der Komponenten der Ghostrunner App. Notwendig sind für die Aufzeichnung des Laufes beispielsweise eine Möglichkeit der Positions- und Höhenbestimmung. Es muss außerdem eine Möglichkeit der Authentifizierung und Kommunikation mit dem Webserver geben. Die Android Plattform wird auf mögliche Lösungen untersucht, welche hier beschrieben werden.
\subsubsection{Kommunikation mit dem Webserver}
Für die Kommunikation mit dem Webserver muss eine Internetverbindung zur Verfügung stehen. Diese ist bei allen Geräten, auf denen unsere App laufen soll Standard. Programmatisch wird also nur ein HTTP-Client benötigt, der von der Android-Plattform bereitgestellt wird. Er ermöglicht, dass  HTTP-Anfragen wie GET und POST gestellt werden und Informationen in HTTP-Header und Body übergeben werden können. Beim Warten auf Antworten vom Webserver kommt es automatisch zu nicht vorhersehbaren Verzögerungen. Android erlaubt es aus diesem Grund nicht, diese Netzwerkanfragen im Main Thread der App zu starten, weil sonst während der Wartezeiten die komplette Benutzeroberfläche einfriert. Bei den Standard HTTP-Clients von Android kann die Netzwerkanfrage durch die Benutzung der Klasse AsyncTask in einen separaten Thread ausgelagert werden. \cite{androidnetwork}

Vereinfacht werden kann dieser Schritt durch die Benutzung des Android Asynchronous HTTP Client. Die quelloffene Bibliothek bietet einfache funktionen für die HTTP-Anfragen GET, POST, PUT und DELETE, die für die Kommunikation mit RESTful-APIs notwendig sind und empfängt Antworten vom Server automatisch asynchron, wodurch der UI-Thread nicht blockiert wird. \cite{loopj}
\subsubsection{Anmeldung und Authentifizierung}
Ein weiterer wichtiger Aspekt ist die Authentifizierung beim Webserver. Nach einer Anmeldung mit Nutzername und Passwort wird vom Server ein Sicherheitstoken erstellt, das bis zu seinem ebenfalls vom Server definierten Ablaufdatum von Client benutzt werden kann, um sich anzumelden. So kann bei einem eventuellen Angriff auf die Netzwerkkommunikation nur noch ein zeitlich, nicht mehr die vollständigen
Es macht Sinn, diese Authentifizierung an einer einzigen Stelle im Client zu behandeln.
%TODO
\subsubsection{Positionsbestimmung}
Für eine genaue Laufanalyse muss zu jedem Zeitpunkt die Position des Läufers bekannt sein, denn daraus lassen sich Geschwindigkeit und gelaufene Strecke berechnen. Die Positionsbestimmung erfolgt über das eingebaute GPS-Modul des Smartphones, dessen Genauigkeit in Städten durch WLAN-basierte Ortung und GSM-Ortung durch das Mobilfunknetz verbessert werden kann. Die Module zur Ortung können über das Package android.location der Android API angesprochen werden. Eine Positionsbestimmung ist also mit Boardmitteln eines Android Smartphones ohne Umwege möglich. Eine neuere und verbesserte Möglichkeit bietet die Google Location Services API. Sie ist Teil der Google Play Services, also auf allen Android Geräten verfügbar, die diesen und andere Google Dienste installiert haben, was einem Großteil der Geräte entspricht. Die verschiedenen Ortungsmöglichkeiten werden hier optimiert und zusammengeführt. Programmierer können auf einfache Weise Positionsupdates anfordern und diese über verschiedene Parameter bezüglich Genauigkeit, Updatehäufigkeit und Akkuverbrauch seinen Bedürfnissen anpassen. \cite{androidlocation}
\subsubsection{Höhenbestimmung}
Zusätzlich zu Positions- und Zeitmessung wird für unsere Anwendung noch eine weitere Variable - die Steigung - benötigt. Wenn Läufer verschiedene Strecken laufen, muss diese berücksichtigt werden, um einen fairen Vergleich zu schaffen. Dazu soll später Läufern, die eine größere Steigung überwinden mussten als andere ein Zeitbonus zugesprochen werden.

Für die Bestimmung der Höhe gibt es verschiedene Möglichkeiten, die im Folgenden kurz erläutert werden.
\paragraph{Höhenbestimmung per GPS}
Grundsätzlich ist per GPS eine dreidimensionale Positionsbestimmung möglich, also neben der horizontalen Positionierung auch eine vertikale Höhenmessung. Diese kann jedoch aufgrund der für horizontale Positionsbestimmung optimierten Positionierung der GPS-Satelliten starken Schwankungen unterliegen. Insbesondere in Städten kommt hierzu das Problem der Reflektion des GPS Signals an hohen Gebäuden, durch die die Positionsgenauigkeit weiter beeinträchtigt wird. Die Beeinträchtigung ist horizontal weniger signifikant als vertikal, und wird durch die Nutzung der im vorherigen Abschnitt genannten zusätzlichen Positionierungsmethoden noch weiter optimiert. Vertikal ist eine solche Optimierung nicht möglich. Noch größer ist die Fehlersignifikanz bei dem Versuch, die Höhe über Normalnull zu berechnen, die von dem vom GPS-System genutzten rein mathematischen Ellipsoid WGS-84 abweicht. Durch die Umrechnung vergrößern sich entsprechende Fehler. \cite{gladstone} Letzeres ist allerdings für unsere Arbeit aber nicht relevant, da wir keine genaue Höhe, sondern nur die relativen Unterschiede für die Steigungsberechnung benötigen. Trotzdem können die möglichen starken Schwankungen der gemessenen Höhe für unsere Anwendung zum Problem werden.
\paragraph{Höhenbestimmung per Web-API}
%TODO
\paragraph{Höhenbestimmung per SRTM-Rohdaten}
%TODO
\paragraph{Kombination verschiedener Methoden}
%TODO anpassen
Insbesondere durch Kombination von GPS und und Nutzung der SRTM-Daten sollten sich sehr genaue Ergebnisse erzielen lassen. Die Implementierung des Höhenbestimmungsmoduls sollte also flexibel genug sein, um das zuzulassen. Erreicht wird diese Flexibilität durch die Implementierung eines Interfaces ElevationService, das die Methode getElevation(double latitude, double longitude) besitzt. Durch Nutzung dieses Interfaces können verschiedene Services einfach ausgetauscht oder mit wenig zusätzlichem Programmieraufwand kombiniert werden. Hier muss nur noch ein Algorithmus entwickelt werden, der bestimmt, auf welche Weise verschiedene Höhendaten kombiniert werden. Für die Studienarbeit haben wir uns aber für die explizite Implementierung der SRTM-Methode entschieden, Veränderungen in späteren Versionen sind durch das Interface jederzeit ohne großen Aufwand möglich.
\subsubsection{Aufzeichnen des Laufes}
%TODO
\subsubsection{Frontend der Android App}
%TODO
\subsubsection{Darstellung des Laufes}
%TODO

\subsection{Analyse von Entitäten}
%TODO ER Diagramm aufgrund von use cases: gruppen, läufe und so quatsch